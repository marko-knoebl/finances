var konto;

(function() {

  "use strict";

  /**
   * Returns a deterministic random number generator based on a seed
   */
  var makeRand = function(seed) {
    return function() {
      seed ++;
      return ((Math.sin(seed) * 10000) % 0.5) + 0.5;
    }
  };

  konto = {};

  konto.Dataset = function() {
    /**
     * A dataset that describes related bank accounts
     * and transactions
     * If prototype is removed this will be a nice JSON
     * representation of the data
     */
    this.transactions = [];
    // always include one account representing "the rest of the world"
    this.accounts = [
      {
        id: "world",
        initialBalance: 0
      }
    ];
  };

  /**
   * Add a new account to the dataset
   * dataset.addAccount({id: 'main', openDate: '2015-03-04'});
   */
  konto.Dataset.prototype.addAccount = function(parameters) {
    if (parameters === undefined) {
      throw new Error("addAccount cannot be called without arguments");
    }
    if (!parameters.id) {
      throw new Error("cannot create account without assigning an id");
    }
    var account = {};
    ;['id', 'initialBalance', 'openDate'].forEach(function(parameter) {
      if (parameters[parameter] !== undefined) {
        account[parameter] = parameters[parameter];
      }
    });
    this.accounts.push(account);
    return account;
  };

  /**
   * Add a new transaction to the dataset
   * dataset.addTransaction({date: '2015-02-03', origin: 'main',
                             destination: 'world'});
   */
  konto.Dataset.prototype.addTransaction = function(parameters) {
    if (parameters.amount === undefined || parameters.origin === undefined ||
        parameters.destination === undefined || parameters.date === undefined) {
      throw new Error("'origin', 'destination', 'amount' and 'date' must be" +
                      'specified for all transactions');
    }
    if (parameters.amount < 0) {
      throw new Error('Transaction amounts must be positive.' +
                      'Switch origin and destination');
    }
    try {this.getAccount({id: parameters.origin})}
    catch (e) {throw new Error('account not found: ' + parameters.origin);}
    try {this.getAccount({id: parameters.destination})}
    catch (e) {throw new Error('account not found: ' + parameters.destination);}
    var transaction = {
      amount: parameters.amount,
      origin: parameters.origin,
      destination: parameters.destination,
      date: parameters.date
    };
    if (parameters.details !== undefined) {
      transaction.details = parameters.details;
    }
    this.transactions.push(transaction);
    return transaction;
  };

  konto.Dataset.prototype.getRandomTransactionData = function(number, seed) {
    seed = seed || 1;
    var sampleDetails = [
      'mcDonalds',
      'Billa dankt',
      'Zielpunkt dankt',
      'Miete',
      'OMV',
      'Hofer',
      'Investmentdepot',
      'Wiener Linien',
      'Versicherung',
      'Subway',
      'Strom',
      'A1',
      'Trafik',
      'Ikea',
      'Amazon',
      'H&M',
      'Konzert',
      'Geschenk'
    ];
    var date = new Date('2013-07-02');
    var transactions = [];
    var rand = makeRand(seed);
    for (var i = 0; i < number; i ++) {
      var r = rand()
      if (r < 0.125) {
        transactions.push({
          id: i,
          date: date.toISOString().slice(0, 10),
          origin: 'world',
          destination: 'main',
          amount: Math.pow(rand(), 0.3) * 2000,
          details: 'Gehalt'
        });
      } else if (r < 0.3){
        transactions.push({
          id: i,
          date: date.toISOString().slice(0, 10),
          origin: 'main',
          destination: 'cash',
          amount: 200,
          details: 'Bankomat'
        });
      } else if (r < 0.7){
        transactions.push({
          id: i,
          date: date.toISOString().slice(0, 10),
          origin: 'main',
          destination: 'world',
          amount: Math.pow(rand(), 5) * 1300,
          details: sampleDetails[Math.floor(rand()*sampleDetails.length)]
        });
      } else {
        transactions.push({
          id: i,
          date: date.toISOString().slice(0, 10),
          origin: 'cash',
          destination: 'world',
          amount: Math.pow(rand(), 5) * 100,
          details: sampleDetails[Math.floor(rand()*sampleDetails.length)]
        });
      }
      var delta = rand() * 8;
      var date = new Date(date);
      date.setDate(date.getDate() + delta);
    }
    return transactions;
  };

  /**
   * retrieve an account (e.g. by id)
   * dataset.getAccount({id: 'world'});
   */
  konto.Dataset.prototype.getAccount = function(query) {
    for (var i in this.accounts) {
      var account = this.accounts[i];
      if (query[Object.keys(query)[0]] === account[Object.keys(query)[0]]) {
        return account;
      }
    }
    throw new Error('query did not match any account: ' +
                    JSON.stringify(query));
  };

  /**
   * get the balance of an account for a specific date
   */
  konto.Dataset.prototype.getBalance = function(account, date) {
    if (account === undefined) {
      throw new Error('account must be specified')
    }
    if (!date) {
      // by default, include all transactions
      // date should be 'greater' than any other date
      date = 'a';
    }
    var balance = 0;
    this.transactions.forEach(function(transaction) {
      if (transaction.date <= date) {
        if (transaction.destination === account) {
          balance += transaction.amount;
        } else if (transaction.origin === account) {
          balance -= transaction.amount;
        }
      }
    });
    return balance;
  };

  /**
   * retrieve a set of transactions that match a single query
   * dataset.getTransactions({destination: 'world'});
   */
  konto.Dataset.prototype.getTransactions = function(query) {
    var result = [];
    this.transactions.forEach(function(transaction) {
      if (query[Object.keys(query)[0]] === transaction[Object.keys(query)[0]]) {
        result.push(transaction);
      }
    });
    return result;
  };

  /**
   * retrieve a set of transactions from a specified account
   * The transactions will be in chronological order
   */
  konto.Dataset.prototype.getTransactionsByAccount = function(account) {
    return this.transactions.filter(function(transaction) {
      return transaction.origin === account || transaction.destination === account;
    }).sort(function(a, b) {
      if (a.date > b.date) {return 1;}
      else if (a.date === b.date) {return 0;}
      else {return -1;}
    });
  }

  /**
   * set the (current) balance
   * adds a new initial transaction which accounts for the difference;
   * this initial transaction will have 'details': 'start tracking' and
   * 'startTracking': true
   */
  konto.Dataset.prototype.setCurrentAccountBalance = function(accountId, balance) {
    var transactions = this.getTransactionsByAccount(accountId);
    var transactionSum = 0;
    transactions.forEach(function(transaction) {
      if (transaction.destination === accountId) {
        transactionSum += transaction.amount;
      } else {
        transactionSum -= transaction.amount;
      }
    });
    var initialBalance = balance - transactionSum;
    var account = this.getAccount({id: accountId});
    var firstTransactionDate = transactions[0].date;
    var initialTransaction = {
      origin: 'world',
      destination: account.id,
      amount: initialBalance,
      date: firstTransactionDate,
      startTracking: true,
      details: 'start tracking'
    };
    this.transactions.push(initialTransaction);
  };

})();
